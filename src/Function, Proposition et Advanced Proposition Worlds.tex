\documentclass[french,frenchkw]{article}
\usepackage[utf8]{inputenc}
\usepackage{natbib}
\usepackage{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tabto}
\usepackage[T1]{fontenc}

\graphicspath{{./Images/}}


\title{Projet de Mathématiques : Assistant de Preuves}
\author{Ivan Hasenohr (pour cette partie)}
\date{Mars 2020}
\begin{document}
\maketitle
\paragraph{Exact, Intro, Have, Apply}
Ici nous allons présenter 4 techniques fondamentales pour l'utilisation de fonctions, une fonction en Lean étant exactement une fonction mathématique, donc un objet abstrait qui prend en argument un élément d'un ensemble A et renvoie un élément d'un ensemble B.\\
\textbf{Exact}\\
La première de ces tactiques est \textit{exact}. Elle permet de dire à Lean que le but recherché correspond exactement à ce que vous lui indiquez. Par exemple, si le but est un élément de P, et que vous disposez de $p \in P$, alors \textit{exact p,} terminera la preuve. De même, si le but est un élément de Q, et que vous disposez d'un élément p de P et d'une fonction f de P dans Q, alors \textit{exact f(p),} terminera la preuve.\\
\textbf{Intro} \\
Lorsque vous manipulez des fonctions, Lean peut vous demander de créer une fonction d'un ensemble P dans un autre ensemble Q. Une méthode est alors de disposer d'un élément de P à partir duquel vous fabriquerez un élément de Q. \textit{intro p,} fait cela : vous disposerez alors d'un élément p de P et votre but changera de $P \implies Q$ à Q. \\
De façon similaire, \textit{intros} permet d'introduire plusieurs variables/fonctions consécutives.\\
\textbf{Have} \\
Cette technique permet de nommer de nouvelles variables : par exemple, si vous disposez de $p \in P$ et de f : $P \implies Q$, alors \textit{have q : Q := f(p),} vous permet de créer un élément $q = f(p)$.\\
\textbf{Apply}\\
Cette technique vous permet de modifier le but sans rajouter de variables : de fait, elle raisonne comme ceci : vous avez pour but un élément de Q. Or vous disposez d'une fonction f : $P \implies Q$. De ce fait, pour disposer d'un élément de Q, il vous suffit de disposer d'un élément de P, car f(p) sera dans Q. \textit{apply f,} fait exactement ça, et donc changera le but de Q en P.\\


\paragraph{IV : Function World}
Ce monde nous introduit un outil fondamental de Lean : les fonctions. \\
Un élément important à remarquer est qu'en Lean, toutes les fonctions sont curryfiées.\\
La manipulation des fonctions ne pose pas de difficultés particulières, une fois maîtrisées les techniques de base que sont exact, intro, have et apply.\\
Voici un exemple de niveau de ce monde, le niveau 6, qui demande de créer une fonction de fonctions assez complexe, et qui utilise le fait que ces fonctions sont curryfiées. \\
L'énoncé se formule comme ceci : \\
$(P Q R : Type) : (P \implies (Q \implies R)) \implies ((P \implies Q) \implies (P \implies R))$\\
La preuve est de fait assez simple : \\
\textit{intros f g p,} -- On introduit les différents éléments/fonctions pour créer la fonction demandée \\
\textit{apply f p,} -- On modifie le but à l'aide de la fonction curryfiée \\
\textit{exact g(p),} -- On trouve le résultat demandé \\
Ce qui conclut la preuve.\\

\paragraph{V : Proposition World} 
Dans ce monde on aborde un aspect fondamental de l'assistant de preuves Lean : comment modélise-t-on une preuve ? Qu'est-ce qu'une preuve ? Lean le modélise comme ceci : Si l'on prend une proposition P, vraie ou faux, peu importe. Alors cette proposition est modélisée par l'ensemble des preuves qui la prouve. Ainsi, par exemple, si la commutativité de la multiplication est un théorème que l'on note $M_C$ , alors $M_C$ est l'ensemble des preuves de cette commutativité.\\
C'est ici que les fonctions prennent toute leur importance : pour montrer qu'une proposition A entraîne une autre proposition B, il suffit de montrer qu'à partir d'un élément de A on peut créer un élément de B, ce qui revient à créer une fonction de A vers B. En effet, si A entraîne B, alors une preuve de A suffit pour prouver B, et donc $a \in A \implies a \in B$. Une fonction $f : A \xrightarrow{} B$ en Lean appliquée (avec apply) à un but B revient donc à dire "Pour montrer B, il suffit de montrer A".\\
\\
Pour illustrer ce point, voici un exemple simple, le tout premier niveau de Proposition World. \\ \\
\textbf{Lemme} : if P is true and $P \implies Q$ is true, then Q is true. \\ \\
Soit en Lean : \textit{(P Q : Prop) (p : P) (h : $P \implies Q$) : Q} \\
Donc, en français, on dispose d'un élément (d'une preuve) de P, et d'une fonction de P dans Q (i-e d'une preuve que si P est vrai alors Q aussi), trouvons un élément de Q (montrons que Q est vrai). \\
Ce qui se résout tout aussi trivialement : \textit{exact h(p),}.\\
\\
Un autre niveau intéressant est le niveau 8, qui propose une preuve du lemme suivant : \\
\\
\textbf{Lemme} : ($P \implies Q) \implies (\lnot Q \implies \lnot Q)$. \\
\\
En Lean, on demande donc de créer un élément de l'ensemble des preuves du Lemme, soit créer une fonction qui va de l'ensemble des preuves que $P \implies Q$ vers l'ensemble des preuves que $\lnot Q \implies \lnot Q$.
\\
Pour cela, la première étape est de disposer d'une preuve de $P \implies Q$ :\\
\textit{intro f,}\\
Lean nous demande alors de créer un élément de $\lnot Q \implies \lnot Q$, qui serait l'image de la fonction qu'il nous est demandé de créer.\\
L'astuce est ensuite de revenir à la définition de $\lnot P$ : $\lnot P$ ssi $P \implies false$. On retranscrit cette définition : \\
\textit{repeat\{rw not\_iff\_imp\_false\},} \\
Le but est alors réécrit en $(Q \implies false) \implies P \implies false$, ce qui revient à créer une fonction curryfiée des éléments de $(Q \implies false) \times P$ vers les preuves de $false$\\
On réapplique la même technique d'introduire un élément de chacun des ensembles de départ : \\
\textit{intros h p,}\\
On dispose alors d'un élément p de P, d'une fonction f de P dans Q et d'une fonction h de Q dans $false$, et il nous faut créer une preuve de $false$, qui est facilement trouvable avec : \\
\textit{exact h(f(p)),}\\
Ce qui conclut la preuve.


\paragraph{VI : Advanced Proposition World}
Dans ce monde on démontre à l'aide de fonctions et de nouvelles méthodes les règles de base de la manipulation d'intersection et d'union de propositions. Un exemple combinant la plupart des nouvelles méthodes est le Lemme suivant : \\
\\
\textbf{Lemme} : Soient P,Q et R trois propositions. \\
ALors $P\land(Q\lor R) \longleftrightarrow (P\land Q)\lor(P\land R)$.\\
\\
Ici on ne démontrera que l'implication directe, l'implication réciproque se faisant de façon similaire.\\
Pour séparer les implications, une technique existe : \textit{split}, qui permet de montrer d'abord l'implication directe puis l'implication réciproque. A noter que cette technique permet aussi de séparer le but en plusieurs buts lorsqu'on a à montrer une intersection de propositions.\\
Pour gérer les unions de propositions, la technique \textit{cases} existe et permet, par exemple, quand on sait que $P\lor Q$, dans un premier temps supposer P puis supposer Q. Cette technique permet aussi de séparer les intersections connues en plusieurs nouvelles données : si l'on a un élément pq de $P\land Q$, \textit{cases pq with p q} nous renvoie deux éléments p et q de P et Q respectivement.\\
Finalement, lorsqu'on doit montrer une union de propositions, il suffit d'en montrer une, et les techniques \textit{left} et \textit{right} nous permettent de choisir la proposition à démontrer.\\
La preuve est donc la suivante : \\

\textit{intro h,}     -- h \in $P\land (Q\lor R)$\\ 
\textit{cases h with p qor,}     -- p \in P , qor \in $Q\lor R$\\
\textit{cases qor with q r,}     -- On sépare en deux cas en fonction de l'union :\\ 

-- Premier cas q \in Q\\
\textit{left,}   - $On choisit de montrer P\land Q$\\
\textit{split,}     -- On sépare en deux buts\\
\textit{exact p,}\\
\textit{exact q,}\\

-- Deuxième cas : r \in R\\
\textit{right,}     - $On choisit de montrer P\land R$\\
\textit{split,}     -- On sépare en deux buts\\
\textit{exact p,}\\
\textit{exact r,}\\
Ce qui conclut la preuve de l'implication directe.

\bibliographystyle{plain}
\end{document}
