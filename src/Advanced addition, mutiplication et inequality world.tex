\paragraph{Advanced Addition World : Level 10}

Ce premier lemme paraît tout à fait naturel, on ne peut pas obtenir 0 en additionnant des entiers naturels strictements positifs, mais il demande tout de même une distionction de cas et une preuve par l'absurde. 
Ce lemme n'est vrai que dans les naturels.

\begin{verbatim}
lemma add_left_eq_zero {{a b : mynat}} : a + b = 0 → b = 0 :=
begin [nat_num_game]
  intro H,
  --On fait une distinction de cas
  --Soit 'b = 0' soit il existe d : mynat tel que 'b = succ(d)' :
  cases b with d,

  --Cas 'b = 0', le goal devient '0 = 0', la résolution est triviale :
  refl,

  --Cas 'b = succ(d)', le goal devient 'succ d = 0'
  --Ce qui est impossible, cela contredit l'axiome de Peano 'zero_ne_succ'
  --On va donc faire une preuve par l'absurde :
  rw add_succ at H, --on fait rentrer a dans le succ 
  exfalso, -- le goal est impossible à prouver donc on le change en 'faux'
  exact succ_ne_zero H,
  --D'après le théorème succ_ne_zero une hypothèse comme H implique 'faux'
  --On a donc prouver que l'hypothèse '∃d : mynat tel que b = succ(d)' est fausse !
end
\end{verbatim}

\paragraph{Advanced Multiplication World : Level 4}

Ce théorème consiste à prouver l'injectivité de la multiplication dans les naturels.
L'idée est instinctive mais la preuve nécessite en réalité beaucoup de distinctions de cas et l'utilisation d'une nouvelle tactic, 'revert'.
\begin{verbatim}
theorem mul_left_cancel (a b c : mynat) (ha : a ≠ 0) : a * b = a * c → b = c :=
begin
  revert b,
  --On ne considère plus b comme une hypothèse,
  --à la place, on rajoute un '∀ (b : mynat)' au goal
  --Ce sera utile plus tard, dans l'hypothèse d'induction
  
  -- On fait une induction sur c :
  induction c with n hn,

  --Le cas de base '∀ (b : mynat), a * b = a * 0 → b = 0' :
  rw mul_zero, --On simplifie
  intros b h, --On introduit un b et l'hypothèse 'h : a * b = 0'
  rw mul_eq_zero_iff a b at h, --h est équivalent à 'a = 0 or b = 0' donc on la réécrit
  
  --On casse le 'a = 0 or b = 0' en deux cas:
  cases h with hha hhb,
  
  --Si 'a = 0' (goal : 'b = 0') :
  --On a 'a ≠ 0' en hypothèse donc on sait que ce cas est impossible
  --On va donc faire une preuve par l'absurde :
  exfalso, -- goal = 'false'
  apply ha, -- goal = 'a = 0'
  exact hha, --Il n'y a plus qu'à appliquer l'hypothèse de disjonction de cas
  
  --Si 'b = 0' (goal : 'b = 0'), c'est trivial :
  exact hhb,

  --Le cas d'induction (goal : '∀ (b : mynat), a * b = a * succ n → b = succ n') :
  intros b h, --On introduit un b et l'hypothèse 'h : a * b = a * succ n'
  --Le goal est juste 'b = succ n' maintenant
  --On fait une distinction de cas sur b :
  cases b with c,

  --Cas 'b = 0' (goal : '0 = succ n') :
  --Cela contredit l'axiome de Peano 'zero_ne_succ', on va donc passer par l'absurde :
  rw mul_zero at h, --On simplifie h pour obtenir ' h : 0 = a * succ n'
  exfalso,
  apply mul_pos a (succ n), --On a besoin de démontrer les hypothèses de mul_pos :
  --Hypothèse 'a ≠ 0' :
  exact ha,
  --Hypothèse 'succ n ≠ 0' :
  exact succ_ne_zero n,
  --Retour à la preuve par l'absurde :
  symmetry,
  exact h,

  --Cas 'b = succ c' (goal : 'succ c = succ n') :
  repeat {rw succ_eq_add_one},
  rw add_right_cancel_iff, --On simplifie le goal pour lui appliquer l'hypothèse de récurrence
  --C'est là que le 'revert b' prend tout son importance car le goal est 'c = n'
  --On n'aurait pas pu appliquer l'HR si elle prenait un b particulier
  apply hn,
  --Il ne reste plus qu'a simpplifier l'hypothèse h :
  repeat {rw mul_succ at h},
  rw add_right_cancel_iff at h,
  exact h,
end
\end{verbatim}

\paragraph{Inequality World Level 15}

Dans la suite, nous allons définir > tel que :
\begin{verbatim}
    a < b := a ≤ b ∧ ¬ (b ≤ a)
\end{verbatim}
Mais la définition :
\begin{verbatim}
    a < b := succ a ≤ b
\end{verbatim}
est plus pratique à utiliser et mathématiquement équivalente.
Nous allons donc prouver  que 
\begin{ve}
a ≤ b ∧ ¬ (b ≤ a) → succ a ≤ b
\end{ve}
dans ce lemme (l'autre partie de l'équivalence est le niveau 16).

\begin{verbatim}
lemma lt_aux_one (a b : mynat) : a ≤ b ∧ ¬ (b ≤ a) → succ a ≤ b :=
begin
  --On commence par transformer 'a ≤ b ∧ ¬ (b ≤ a)' en 2 hypothèses :
  intro h,
  cases h with hab htba,
  --On introduit 'c tel que b = a + c'
  cases hab with c hc,

  --On ne peut rien faire à ce niveau car le cas 'b = 0' pose problème
  --On fait donc une distinction de cas sur b :
  cases b,

  --Cas 'b = 0' (impossible donc par l'absurde) :
  exfalso,
  apply htba,
  exact zero_le a,

  --Cas 'b = succ b' (goal : succ a ≤ succ b) :
  --Là, c'est le cas 'a = 0' qui nous pose problème
  cases a,

  --Cas 'a = 0' (trivial vu que 'b != 0') :
  apply succ_le_succ,
  exact zero_le b,

  --Cas 'a = succ a' (goal : 'succ (succ a) ≤ succ b') :
  rw hc,
  rw succ_add,
  apply succ_le_succ, --goal : 'succ a ≤ a + c'
  
  --Cette inégalité est impossible si 'c = 0'
  cases c,

  --Cas 'c = 0'
  rw add_zero at hc,
  exfalso,
  apply htba,
  use 0,
  rw add_zero,
  symmetry,
  exact hc,

  --Cas 'c = succ c' (goal : 'succ a ≤ a + succ c') :
  --Les +1 se simplifient
  rw add_succ,
  apply succ_le_succ,
  use c,
  refl,
end
\end{verbatim}